<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Node.js（二）——模块和包 | Hexo</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="这篇文章是Node.js第二篇，之所以要来写这些，是因为想把看过的书都记录下来，第一篇文章是从头开始讲Node.js——异步与事件驱动。看的书名叫做《Node.js开发指南》从元旦之后就给自己立了一个flag，每个星期看完以本书，最近比较闲，主要是花在这部书上的精力也还蛮多的吧，现在已经翻了1/4了，嗯，一个星期已经过去一半了，不知道能不能看完呀。闲话少说，来说重点吧。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Node.js（二）——模块和包"/>
  <meta property="og:site_name" content="Hexo"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="true" title="Hexo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'true', 'auto');
	ga('send', 'pageview');

</script>


</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Hexo</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="page">
  
  <div class="post-content">
    <header>
      
      
  
    <h1 class="title">Node.js（二）——模块和包</h1>
  

    </header>
    <div class="entry">
      
        <p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1490294802347&amp;di=b10b98c2cf88747063e49ec496a8c9df&amp;imgtype=0&amp;src=http%3A%2F%2Fb.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F77094b36acaf2edd9a034601891001e938019363.jpg" alt="这里写图片描述"></p>
<p>这篇文章是Node.js第二篇，之所以要来写这些，是因为想把看过的书都记录下来，第一篇文章是从头开始讲Node.js——异步与事件驱动。<br>看的书名叫做《Node.js开发指南》<br>从元旦之后就给自己立了一个flag，每个星期看完以本书，最近比较闲，主要是花在这部书上的精力也还蛮多的吧，现在已经翻了1/4了，嗯，一个星期已经过去一半了，不知道能不能看完呀。闲话少说，来说重点吧。<br><a id="more"></a><br>这一篇主要是讲模块和包<br>主要分四节：</p>
<ul>
<li>什么是模块</li>
<li>如何创建并加载模块</li>
<li>如何创建包</li>
<li>如何使用包管理器</li>
</ul>
<h1 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h1><blockquote>
<p>模块是 Node.js  应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是 JavaScript  代码、JSON  或者编译过的 C/C++ 扩展。</p>
</blockquote>
<p>简而言之，也就是说一个文件就是一个模块。</p>
<h1 id="如何创建并加载模块"><a href="#如何创建并加载模块" class="headerlink" title="如何创建并加载模块"></a>如何创建并加载模块</h1><p>前面说了一个node.js文件就是一个模块，那么如何创建它，或者说加载这个模块呢？<br>node.js遵循commonJS的规范，使用require加载和export导出。<br>什么是commonJS规范，我之前也有讨论过:<a href="http://blog.csdn.net/sinat_25127047/article/details/52502800" target="_blank" rel="external">Javascript模块化编程——使用AMD，CommonJS，ES Harmony</a><br>另外模块的导出，我也转过一篇很好的文章，因为我们有些时候会导出整个node.js文件，有些时候只需要一个对象。<a href="http://blog.csdn.net/sinat_25127047/article/details/52369018" target="_blank" rel="external">Node.js中exports和module.exports有什么不同？</a><br>这里跟着书上的代码再过一遍吧。<br>module.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name;</div><div class="line">exports.setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123;</div><div class="line">    name = thyName;</div><div class="line">&#125;</div><div class="line">exports.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getModule.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(<span class="string">'./module.js'</span>);</div><div class="line">myModule.setName(<span class="string">'daisy_Hawen'</span>);</div><div class="line">myModule.sayHello()</div></pre></td></tr></table></figure>
<p>这个确实跟创建一个对象，再声明一个对象没什么区别啊。但是在node.js这种写后台语言的环境下这么做或许好一些吧。<br>上面这段代码感觉跟下面这段代码完全没区别，其实就是换了一种CommonJS规范的写法而已，我觉得。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name,</div><div class="line">        setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123;</div><div class="line">            name = thyName</div><div class="line">        &#125;,</div><div class="line">        sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + name);</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">setName</span>: <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123;</div><div class="line">            setName(thyName)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            sayHello()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> myModule = <span class="keyword">new</span> <span class="built_in">module</span>()</div><div class="line">myModule.setName(<span class="string">'Hawen'</span>);</div><div class="line">myModule.sayHello();</div></pre></td></tr></table></figure>
<p>这种接口封装方式比许多语言要简洁得多，同时也不失优雅，未引入违反语义的特性，符合传统的编程逻辑。在这个基础上，我们可以构建大型的应用程序，npm 提供的上万个模块都是通过这种简单的方式搭建起来的。<br>但是在后续用到npm里面肯定非常好吧。</p>
<h2 id="单次加载"><a href="#单次加载" class="headerlink" title="单次加载"></a>单次加载</h2><p>上面这个例子有点类似于创建一个对象，但实际上和对象又有本质的区别，因为 require 不会重复加载模块，也就是说无论调用多少次 require，获得的模块都是同一个。我们在 getmodule.js 的基础上稍作修改： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myModule1 = <span class="built_in">require</span>(<span class="string">'./module.js'</span>);</div><div class="line">myModule1.setName(<span class="string">'daisy_Hawen'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> myModule2 = <span class="built_in">require</span>(<span class="string">'./module.js'</span>);</div><div class="line">myModule2.setName(<span class="string">'ahahah'</span>);</div><div class="line">myModule2.sayHello() <span class="comment">//helloahahah</span></div><div class="line">myModule1.sayHello();<span class="comment">//helloahahah</span></div></pre></td></tr></table></figure>
<p>但是基于对象的创建就不一样了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name,</div><div class="line">        setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123;</div><div class="line">            name = thyName</div><div class="line">        &#125;,</div><div class="line">        sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + name);</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">setName</span>: <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123;</div><div class="line">            setName(thyName)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            sayHello()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> myModule = <span class="keyword">new</span> <span class="built_in">module</span>()</div><div class="line">myModule.setName(<span class="string">'Hawen'</span>);</div><div class="line"><span class="keyword">var</span> myModule2 = <span class="keyword">new</span> <span class="built_in">module</span>()</div><div class="line">myModule2.setName(<span class="string">'ahahah'</span>);</div><div class="line">myModule.sayHello();<span class="comment">//helloaHawen</span></div><div class="line">myModule2.sayHello();<span class="comment">//helloahahah</span></div></pre></td></tr></table></figure>
<p><strong>区别：通过对象创建的myModule2相当于创建了一个新的module实例，因此myModule2的修改不会影响myModule。<br>但是通过require加载的，每次只加载一个，无论声明多少次require，他们指向的都是同一个对象。</strong><br>这里也就解释了我前面的疑惑。</p>
<h2 id="覆盖exports"><a href="#覆盖exports" class="headerlink" title="覆盖exports"></a>覆盖exports</h2><p>假如我们是将一个对象封装在模块中的话，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name;</div><div class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123;</div><div class="line">        name = thyName;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Hello"</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">exports.Hello = Hello;</div></pre></td></tr></table></figure>
<p>那么在另一个模块中引用该模块就需要 var newHello = new Hello.Hello;这样写来看上去非常不好看</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Hello = <span class="built_in">require</span>(<span class="string">'./sinleobject.js'</span>)</div><div class="line"><span class="keyword">var</span> newHello = <span class="keyword">new</span> Hello.Hello;</div><div class="line"></div><div class="line">newHello.setName(<span class="string">'hawen'</span>);</div><div class="line">newHello.sayHello();</div></pre></td></tr></table></figure>
<p>因此把上面的exports.Hello = Hello;改成 module.exports = Hello; 就完美了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Hello = <span class="built_in">require</span>(<span class="string">'./sinleobject.js'</span>)</div><div class="line"><span class="keyword">var</span> newHello = <span class="keyword">new</span> Hello;</div><div class="line"></div><div class="line">newHello.setName(<span class="string">'hawen'</span>);</div><div class="line">newHello.sayHello();</div></pre></td></tr></table></figure>
<p>注意，模块接口的唯一变化是使用 module.exports = Hello 代替了 exports.Hello= Hello 。在外部引用该模块时，其接口对象就是要输出的  Hello   对象本身，而不是原先的 exports。 </p>
<p>事实上，exports  本身仅仅是一个普通的空对象，即 {} ，它专门用来声明接口，本质上是通过它为模块闭包的内部建立了一个有限的访问接口。因为它没有任何特殊的地方，所以可以用其他东西来代替，譬如我们上面例子中的 Hello 对象。<br>警告： </p>
<blockquote>
<p>不可以通过对  exports  直接赋值代替对  module.exports  赋值。 exports  实际上只是一个和  module.exports  指向同一个对象的变量， 它本身会在模块执行结束后释放，但  module 不会，因此只能通过指定  module.exports  来改变访问接口。</p>
</blockquote>
<h2 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h2><p>‘这一节我觉得真的没什么好说的，就直接copy书上的话过来了’<br>模块与文件是一一对应的。文件不仅可以是 JavaScript  代码或二进制代码，还可以是一个文件夹。最简单的包，就是一个作为文件夹的模块。下面我们来看一个例子，建立一个叫做 somepackage  的文件夹，在其中创建 index.js ，内容如下：<br>//somepackage/index.js </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exports.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在  somepackage  之外建立 getpackage.js ，内容如下：<br>//getpackage.js </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> somePackage = <span class="built_in">require</span>(<span class="string">'./somepackage'</span>);</div><div class="line">somePackage.hello();</div></pre></td></tr></table></figure>
<p>我们使用这种方法可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制package.json，我们可以创建更复杂、更完善、更符合规范的包用于发布。 </p>
<h2 id="包的发布"><a href="#包的发布" class="headerlink" title="包的发布"></a>包的发布</h2><p>npm 可以非常方便地发布一个包，比 pip 、gem 、pear  要简单得多。在发布之前，首先需要让我们的包符合 npm 的规范，npm 有一套以 CommonJS 为基础包规范，但与 CommonJS并不完全一致，其主要差别在于必填字段的不同。<br>通过使用 npm init 可以根据交互式问答产生一个符合标准的 package.json，例如创建一个名为 byvoidmodule 的目录，然后在这个目录中运行npm init ： </p>
<p>这样就在 byvoidmodule  目录中生成一个符合 npm  规范的 package.json  文件。创建一个 index.js  作为包的接口，一个简单的包就制作完成了。 在发布前，我们还需要获得一个账号用于今后维护自己的包，使用  npm adduser  根据提示输入用户名、密码、箱，等待账号创建完成。完成后可以使用  npm whoami 测验是<br>否已经取得了账号。<br>接下来，在 package.json  所在目录下运行 npm publish ，稍等片刻就可以完成发布了。打开浏览器，访问 <a href="http://search.npmjs.org/" target="_blank" rel="external">http://search.npmjs.org/</a>  就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用 npm install byvoidmodule 命令来安装它。<br>如果你的包将来有更新，只需要在 package.json  文件中修改  version  字段，然后重新使用 npm publish   命令就行了。如果你对已发布的包不满意（比如我们发布的这个毫无意义的包），可以使用  npm unpublish   命令来取消发布。 </p>
<h1 id="Node-js的调试"><a href="#Node-js的调试" class="headerlink" title="Node.js的调试"></a>Node.js的调试</h1><p><img src="http://img.blog.csdn.net/20170109112436638?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMjUxMjcwNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>  <!--more--> </p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/node-javascript/">node javascript</a>
  </div>

        
        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">Comments</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://yoursite.com/2016/12/01/hehh/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 John Doe
  
  <p>Theme by <a href="https://caisiduo.xyz" target="_blank">LightOne</a></p>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
