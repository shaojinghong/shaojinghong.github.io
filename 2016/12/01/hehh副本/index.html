<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="那些没有踏出的脚步，不如从现在开始"><title>Node.js（二）——模块和包 | 景洪</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Node.js（二）——模块和包</h1><a id="logo" href="/.">景洪</a><p class="description">记录、思考、总结</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Node.js（二）——模块和包</h1><div class="post-content"><p>这篇文章是Node.js第二篇，之所以要来写这些，是因为想把看过的书都记录下来，第一篇文章是从头开始讲Node.js——异步与事件驱动。<br>看的书名叫做《Node.js开发指南》<br>从元旦之后就给自己立了一个flag，每个星期看完以本书，最近比较闲，主要是花在这部书上的精力也还蛮多的吧，现在已经翻了1/4了，嗯，一个星期已经过去一半了，不知道能不能看完呀。闲话少说，来说重点吧。</p>
<p>这一篇主要是讲模块和包<br>主要分四节：</p>
<ul>
<li>什么是模块</li>
<li>如何创建并加载模块</li>
<li>如何创建包</li>
<li>如何使用包管理器</li>
</ul>
<h1 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h1><a id="more"></a> 
<blockquote>
<p>模块是 Node.js  应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是 JavaScript  代码、JSON  或者编译过的 C/C++ 扩展。</p>
</blockquote>
<p>简而言之，也就是说一个文件就是一个模块。</p>
<h1 id="如何创建并加载模块"><a href="#如何创建并加载模块" class="headerlink" title="如何创建并加载模块"></a>如何创建并加载模块</h1><p>前面说了一个node.js文件就是一个模块，那么如何创建它，或者说加载这个模块呢？<br>node.js遵循commonJS的规范，使用require加载和export导出。<br>什么是commonJS规范，我之前也有讨论过:<a href="http://blog.csdn.net/sinat_25127047/article/details/52502800" target="_blank" rel="external">Javascript模块化编程——使用AMD，CommonJS，ES Harmony</a><br>另外模块的导出，我也转过一篇很好的文章，因为我们有些时候会导出整个node.js文件，有些时候只需要一个对象。<a href="http://blog.csdn.net/sinat_25127047/article/details/52369018" target="_blank" rel="external">Node.js中exports和module.exports有什么不同？</a><br>这里跟着书上的代码再过一遍吧。<br>module.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name;</div><div class="line">exports.setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123;</div><div class="line">    name = thyName;</div><div class="line">&#125;</div><div class="line">exports.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getModule.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(<span class="string">'./module.js'</span>);</div><div class="line">myModule.setName(<span class="string">'daisy_Hawen'</span>);</div><div class="line">myModule.sayHello()</div></pre></td></tr></table></figure>
<p>这个确实跟创建一个对象，再声明一个对象没什么区别啊。但是在node.js这种写后台语言的环境下这么做或许好一些吧。<br>上面这段代码感觉跟下面这段代码完全没区别，其实就是换了一种CommonJS规范的写法而已，我觉得。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name,</div><div class="line">        setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123;</div><div class="line">            name = thyName</div><div class="line">        &#125;,</div><div class="line">        sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + name);</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">setName</span>: <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123;</div><div class="line">            setName(thyName)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            sayHello()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> myModule = <span class="keyword">new</span> <span class="built_in">module</span>()</div><div class="line">myModule.setName(<span class="string">'Hawen'</span>);</div><div class="line">myModule.sayHello();</div></pre></td></tr></table></figure>
<p>这种接口封装方式比许多语言要简洁得多，同时也不失优雅，未引入违反语义的特性，符合传统的编程逻辑。在这个基础上，我们可以构建大型的应用程序，npm 提供的上万个模块都是通过这种简单的方式搭建起来的。<br>但是在后续用到npm里面肯定非常好吧。</p>
<h2 id="单次加载"><a href="#单次加载" class="headerlink" title="单次加载"></a>单次加载</h2><p>上面这个例子有点类似于创建一个对象，但实际上和对象又有本质的区别，因为 require 不会重复加载模块，也就是说无论调用多少次 require，获得的模块都是同一个。我们在 getmodule.js 的基础上稍作修改： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myModule1 = <span class="built_in">require</span>(<span class="string">'./module.js'</span>);</div><div class="line">myModule1.setName(<span class="string">'daisy_Hawen'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> myModule2 = <span class="built_in">require</span>(<span class="string">'./module.js'</span>);</div><div class="line">myModule2.setName(<span class="string">'ahahah'</span>);</div><div class="line">myModule2.sayHello() <span class="comment">//helloahahah</span></div><div class="line">myModule1.sayHello();<span class="comment">//helloahahah</span></div></pre></td></tr></table></figure>
<p>但是基于对象的创建就不一样了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name,</div><div class="line">        setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123;</div><div class="line">            name = thyName</div><div class="line">        &#125;,</div><div class="line">        sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + name);</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">setName</span>: <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123;</div><div class="line">            setName(thyName)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            sayHello()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> myModule = <span class="keyword">new</span> <span class="built_in">module</span>()</div><div class="line">myModule.setName(<span class="string">'Hawen'</span>);</div><div class="line"><span class="keyword">var</span> myModule2 = <span class="keyword">new</span> <span class="built_in">module</span>()</div><div class="line">myModule2.setName(<span class="string">'ahahah'</span>);</div><div class="line">myModule.sayHello();<span class="comment">//helloaHawen</span></div><div class="line">myModule2.sayHello();<span class="comment">//helloahahah</span></div></pre></td></tr></table></figure>
<p><strong>区别：通过对象创建的myModule2相当于创建了一个新的module实例，因此myModule2的修改不会影响myModule。<br>但是通过require加载的，每次只加载一个，无论声明多少次require，他们指向的都是同一个对象。</strong><br>这里也就解释了我前面的疑惑。</p>
<h2 id="覆盖exports"><a href="#覆盖exports" class="headerlink" title="覆盖exports"></a>覆盖exports</h2><p>假如我们是将一个对象封装在模块中的话，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name;</div><div class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123;</div><div class="line">        name = thyName;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Hello"</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">exports.Hello = Hello;</div></pre></td></tr></table></figure>
<p>那么在另一个模块中引用该模块就需要 var newHello = new Hello.Hello;这样写来看上去非常不好看</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Hello = <span class="built_in">require</span>(<span class="string">'./sinleobject.js'</span>)</div><div class="line"><span class="keyword">var</span> newHello = <span class="keyword">new</span> Hello.Hello;</div><div class="line"></div><div class="line">newHello.setName(<span class="string">'hawen'</span>);</div><div class="line">newHello.sayHello();</div></pre></td></tr></table></figure>
<p>因此把上面的exports.Hello = Hello;改成 module.exports = Hello; 就完美了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Hello = <span class="built_in">require</span>(<span class="string">'./sinleobject.js'</span>)</div><div class="line"><span class="keyword">var</span> newHello = <span class="keyword">new</span> Hello;</div><div class="line"></div><div class="line">newHello.setName(<span class="string">'hawen'</span>);</div><div class="line">newHello.sayHello();</div></pre></td></tr></table></figure>
<p>注意，模块接口的唯一变化是使用 module.exports = Hello 代替了 exports.Hello= Hello 。在外部引用该模块时，其接口对象就是要输出的  Hello   对象本身，而不是原先的 exports。 </p>
<p>事实上，exports  本身仅仅是一个普通的空对象，即 {} ，它专门用来声明接口，本质上是通过它为模块闭包的内部建立了一个有限的访问接口。因为它没有任何特殊的地方，所以可以用其他东西来代替，譬如我们上面例子中的 Hello 对象。<br>警告： </p>
<blockquote>
<p>不可以通过对  exports  直接赋值代替对  module.exports  赋值。 exports  实际上只是一个和  module.exports  指向同一个对象的变量， 它本身会在模块执行结束后释放，但  module 不会，因此只能通过指定  module.exports  来改变访问接口。</p>
</blockquote>
<h2 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h2><p>‘这一节我觉得真的没什么好说的，就直接copy书上的话过来了’<br>模块与文件是一一对应的。文件不仅可以是 JavaScript  代码或二进制代码，还可以是一个文件夹。最简单的包，就是一个作为文件夹的模块。下面我们来看一个例子，建立一个叫做 somepackage  的文件夹，在其中创建 index.js ，内容如下：<br>//somepackage/index.js </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exports.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在  somepackage  之外建立 getpackage.js ，内容如下：<br>//getpackage.js </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> somePackage = <span class="built_in">require</span>(<span class="string">'./somepackage'</span>);</div><div class="line">somePackage.hello();</div></pre></td></tr></table></figure>
<p>我们使用这种方法可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制package.json，我们可以创建更复杂、更完善、更符合规范的包用于发布。 </p>
<h2 id="包的发布"><a href="#包的发布" class="headerlink" title="包的发布"></a>包的发布</h2><p>npm 可以非常方便地发布一个包，比 pip 、gem 、pear  要简单得多。在发布之前，首先需要让我们的包符合 npm 的规范，npm 有一套以 CommonJS 为基础包规范，但与 CommonJS并不完全一致，其主要差别在于必填字段的不同。<br>通过使用 npm init 可以根据交互式问答产生一个符合标准的 package.json，例如创建一个名为 byvoidmodule 的目录，然后在这个目录中运行npm init ： </p>
<p>这样就在 byvoidmodule  目录中生成一个符合 npm  规范的 package.json  文件。创建一个 index.js  作为包的接口，一个简单的包就制作完成了。 在发布前，我们还需要获得一个账号用于今后维护自己的包，使用  npm adduser  根据提示输入用户名、密码、箱，等待账号创建完成。完成后可以使用  npm whoami 测验是<br>否已经取得了账号。<br>接下来，在 package.json  所在目录下运行 npm publish ，稍等片刻就可以完成发布了。打开浏览器，访问 <a href="http://search.npmjs.org/" target="_blank" rel="external">http://search.npmjs.org/</a>  就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用 npm install byvoidmodule 命令来安装它。<br>如果你的包将来有更新，只需要在 package.json  文件中修改  version  字段，然后重新使用 npm publish   命令就行了。如果你对已发布的包不满意（比如我们发布的这个毫无意义的包），可以使用  npm unpublish   命令来取消发布。 </p>
<h1 id="Node-js的调试"><a href="#Node-js的调试" class="headerlink" title="Node.js的调试"></a>Node.js的调试</h1><p><img src="http://img.blog.csdn.net/20170109112436638?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMjUxMjcwNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>  <!--more--> </p>
</div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/node-javascript/">node javascript</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/12/01/hehh副本/">Node.js（二）——模块和包</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/01/hehh/">Node.js（二）——模块和包</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">景洪.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>