[{"title":"shaojinghong","date":"2017-04-23T02:45:24.000Z","path":"2017/04/23/shaojinghong/","text":"fafjalkhfjxlaf2","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"深入理解css之 —— absolute定位","date":"2017-04-19T03:48:59.000Z","path":"2017/04/19/深入理解css定位/","text":"工欲善其事，必先利其器。前端开发css是一门利器，以前写了很多css样式和布局，用到了很多css技巧，但是很多时候不能熟练并且准确无误运用到业务中，所以我会在后面“深入理解css”系列中做详细系统总结； 这一篇主要总结一下position属性： absolute绝对定位 relative相对定位 position这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在正常流中的默认位置偏移。 absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 relative 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 inherit 规定应该从父元素继承 position 属性的值。 absolute绝对定位；absolute具有两种特性：破坏性，包裹性 破坏性包裹性absolute的应用： 1 、icon绝对定位 type=\"text/css\">1234567891011 .icon&#123; background: yellow; position: absolute; margin: -16px 0 0 2px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span&gt;我是icon的邻元素&lt;/span&gt; &lt;span class=&quot;icon&quot;&gt;icon&lt;/span&gt;&lt;/body&gt; 2、居中显示123456789101112131415161718192021&lt;body&gt; &lt;div style=\"height: 200px\"&gt;&lt;/div&gt; &lt;div class=\"parent\"&gt; &amp;nbsp &lt;span class=\"icon\"&gt;icon&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;style type=\"text/css\"&gt; .icon&#123; background: yellow; width: 100px; position: absolute; margin-left: -50px; &#125; .parent&#123; width: 500px; margin: 0 auto; background: #ccc; text-align: center; &#125;&lt;/style&gt; 实现原理：parent容器设置text－align：center后，&amp;nbsp 居中显示，span标签为绝对定位，它脱离文档流，并且具有跟随性，所以它会跟随在在&amp;nbsp的后面。同样的道理也可以设置为text－align这，这样就出现了侧栏定位的效果。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"总结js数据类型中的Number","date":"2017-04-09T07:11:39.000Z","path":"2017/04/09/总结js数据类型中的Number/","text":"今天又遇到坑了，问题描述如下：通过inputValue=input.value取出文本输入框的值，判断inputValue是否是数字，如果是数字则将它渲染到页面；开始我是这样做的： 第一个坑：123456inputValue=input.valueif(typeof inputValue==number)&#123; render(inputValue);&#125;else&#123; alert(\"请输入数字\");&#125; 这样不行，我查了一下，取出文本输入框的value值数据类型都是“string”；然后我想改进一下，结果跳进了第二个坑，我是这样做的：通过内置函数将Number()转换成Number类型；123456inputValue=Number(input.value);if(typeof inputValue==number)&#123; render(inputValue);&#125;else&#123; alert(\"请输入数字\");&#125; 这样还是不行，因为转换函数Number()的返回值类型一定是Number类型；好吧，我知道怎么改了，Number()返回值有三种情况：整型，浮点型，NaN123456inputValue=Number(input.value);if(inputValue!=NaN)&#123; render(inputValue);&#125;else&#123; alert(\"请输入数字\");&#125; 真的，这样依然不行，这坑剧坑：翻阅《javascript》高级程序设计得知， NaN与任何数值都不相等，包括NaN。 终极解决方案： ECMAScript中定义了全局isNaN()函数，这个函数接受一个参数，该参数可以是任意类型。isNaN()在接收到一个值后，会尝试将这个转换成数值。某些不是数值的值会直接转换成数值，例如字符串“10”或者Boolean值。 而那些不能转换成数值的值将导致函数返回true； 例如： 123456alert(isNaN(NaN)); //truealert(isNaN(10)); //falsealert(isNaN('10')); //falsealert(isNaN('str')); //truealert(isNaN(true)); //false(可以转换成数值1)alert(isNaN('true')); //true(这是字符串)； 所以最终解决方法为：1234567var inputValue=input.value; input.value=''; if(!isNaN(inputValue))&#123; stack.unshift(inputValue); &#125;else&#123; alert(\"请输入数字\");&#125; 总结Number类型Number类型共有三种： 整数 浮点数 NaN Number类型应该是ECMAScript中最令人关注的数据类型了，这种类型使用IEEE754格式来表示整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。为支持各种数值类型，ECMA-262定义了不同的数值字面量。 最基本的数值字面量格式是十进制整数，十进制整数可以像下面这样直接在代码中输入： 1var item =55; //整数 除了以十进制表示外，整数还可以通过八进制（以8为基数）或十六进制（以16为基数）的字面值来表示。其中，八进制字面值的第一位必须是零（0），然后是八进制数字序列（0-7）。如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当做十进制数值解析。请看下面的例子： 123var color1=070; //八进制的56var color2=079; //无效的八进制数值——解析为79var color3=08; //无效的八进制数值——解析为8 八进制字面量在严格模式下是无效的，会导致支持该模式的JavaScript引擎抛出错误。 十六进制字面值的前两位必须是0x，后跟任何十六进制数字（0-9及A-F）。其中，字面A-F可以大写，也可以小写。如下面的例子所示：12var num1=0xA； //十六进制的10var num2=0x1f; //十六进制的31 在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。 1.浮点数值 所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。一下是浮点数值的几个例子： 123var floatNum1=1.1;var floatNum2=0.1;var floatNum3=.1; //有效，但不推荐 由于保存浮点数值需要的内存空间是保存数值的两倍，因此ECMAScript会不失时机地将浮点数值转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样地，如果浮点数值本身表示的就是一个整数（如1.0），那么该值也会被转换为整数，如下面的例子所示： 12var floatNum1=1.; //小数点后面没有数字——解析为1var floatNum2=10.0; //整数——解析为10 对于那些极大或极小的数值，可以用e表示法（即科学计数法）表示的浮点数值表示。用e表示法表示的数值等于e前面的数值乘以10的指数次幂。ECMAScript中e表示法的格式也是如此，即前面是一个数值（可以是整数也可以是浮点数），中间是一个大写或小写的字面E，后面是10的幂中的指数，该幂值将用来与前面的数相乘。下面是一个使用e表示法表示数值的例子：1var floatNum=3.125e7 ; //等于31250000 这个例子中，使用e表示法表示的变量floatNum的形式虽然简洁，但它的实际值则是31250000.在此，e表示法的实际含义就是“3.125乘以10的七次方”。 也可以使用e表示法表示极小的数值，如0.00000000000000003，这个数值可以使用更简洁的3e-17表示。在默认情况下，ECMAScript会将那些小数点后面带有6个零以上的浮点数值转换为以e表示法表示的数值（例如，0.0000003会被转换成3e-7）。 浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1+0.2的结果不是0.3，而是0.300000000000000004。这个小小的舍入误差会导致无法测定特定的浮点数值。例如： if(a+b == 0.3){ //不要做这样的测试 alert(“You got 0.3.”); } 在这个例子中，我们测试的是两个数的和是不是等于0.3。如果这两个数是0.05和0.25，或者是0.15和0.15都不有问题。而如前所述，如果这两个数是0.1和0.2，那么测试将无法通过。因此，永远不要测试某个特定的浮点数值。 2.数值范围 由于内存的限制，ECMAScript并不能保存世界上所有的数值。ECMAScript能够表示的最小数值保存在Number.MN_VALUE中——在大多数浏览器中，这个值是5e-324；能够表示的最大数值保存在Number.MAX_VLAUE中——在大数浏览器中，这个值是1.7976931348623157e+328。如果某次计算结果得到了一个超出JavaScript数值范围值，那么这个数值将被自动转换成特殊的Infinity值。具体来说，如果这个数值是负数，则会被转换成-Infinit（负无穷）,如果这个数值是正数，则会被转换成Infinity(正无穷)。 如上所述，如果某次计算返回了正或负的Infinity值，那么该值将无法继续参与下一次的计算，因为Infinity不能够参与计算的数值。要想确定一个数值是不是有穷的（换句话说，是不是位于最小和最大的数值之间），可以使用sFinite()函数。这个函数在参数位于最小与最大数值之间时会返回true，如下面的例子所示： var result=Number.MAX_VALUE + Number.MAX_VALUE; alert(isFinite(result)); //false 尽管在计算中很少出现某些值超出表示范围的情况，但在执行极小或极大数值的计算时，检测监控这些值是可能的，是必须的。 3.NaN NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来返回数值的操作数未返回数值情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。但ECMAScript中，任何数值除以0会返回NaN，因此不会影响其他代码的执行。 NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多部计算有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身。例如，下面的代码会返回false： alert(NaN == NaN)；//false 针对NaN的这两个特点，ECMAScript定义了isNaN(函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN()接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串“10”或“Boolen”值。而任何不能转换为数值的值都会导致这个函数返回true。请看下面的例子：12345alert(isNaN(NaN)) ; //truealert(isNaN(10)); //false（10是一个数值）alert(isNaN(“10”)); //false(可以被转换成数值10)alert(isNaN(“blue”)); //true(不能转换成数值)alert(isNaN(true)); //false (可以被转换成数值1) 这个例子测试了5个不同的值。测试的第一个值是NaN本身，结果当然会返回true。然后分别测试了数值10和字符串10”，结果这个两个测试都返回了false，因为前者本身就是数值，而后者可以被转换成数值。但是字符串“blue”能被转换成数值，因此函数返回了true。由于Boolean值true可以转换成数值1，因此函数返回false。 4.数值转换 有3个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat(。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这3哥函数对于同样的输入会有返回不同的结果。 Number()函数的转换规则如下。如果是Boolean值，true和false将分别被转换成1和0.如果是数字值，只是简单的传入和返回。如果是null值，返回0。如果是undefined，返回NaN。如果是字符串，遵循下列规则： a.如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即“1”会变成1，“123”会变成123，而“011”会变成11（注意：前导的零被忽略了） b.如果字符串中包含有效的浮点格式，如“1.1”，则将其转换为对应的浮点数值（同样，也会忽略前导零）； c.如果字符串中包含有效的十六进制格式，例如：“0xf”，则将其转换为相同大小的十进制整数数值； d.如果字符串是空的（不包含任何字符），则将其转换为0； e.如果字符串中包含除上述格式之外的字符，则将其转换为NaN。 6.如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString（）方法，然后再次依照前面的规则转换返回的字符串值。 根据这么多的规则使用Number()把各种数据类型转换为数值确实有点复杂。下面还是给出几个具体的例子吧。 1234var num1=Number(\"Hello world!\"); //NaNvar num2=Number(\"\"); //0var num3=Number(\"000011\"); //11var num4=Number(true); //1 首先，字符串”Hello World！”会被转换为NaN，因为其中不包含任何有意义的数字值。空字符串会被转换为0.字符串“000011”会被转换为11，因为忽略了其前导的零。最后，true值被转换为1。 由于Number()函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是parseInt()函数。parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN；也就是说，用parseInt()转换空字符串会返回NaN(Number()对空字符串返回0)。如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如，”123blue”会被转换为1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为22，因为小数点并不是有效的数字字符。 如果字符串中的第一个字符是数字字符，parseInt()也能够识别出各种整数格式（即前面讨论的十进制、八进制和十六进制）。也就是说，如果字符串以”0x”开头且后跟数字字符，就会将其当做一个十六进制整数；如果字符串以”0”开头且后跟数字字符，则会将其当做一个八进制数来解析。 为了更好地理解parseInt()函数的转换规则，下面给出一些例子： 1234567var num1=parseInt(\"1234blue\"); //1234var num1=parseInt(\"\"); //NaNvar num1=parseInt(\"0xA\"); //10(十六进制数)var num1=parseInt(\"22.5\"); //22var num1=parseInt(\"070\"); //56（八进制数）var num1=parseInt(\"70\"); //70（十进制数）var num1=parseInt(\"0xf\"); //15（十六进制数） 在使用parseInt()解析像八进制字面量的字符串时，ECMAScript3和5存在分歧。例如： //ECMAScript 3 认为是56（八进制），ECMAScript 5认为是70（十进制） var num=parseInt(“070”); 在ECMAScript 3 JavaScript引擎中，”070”被当成八进制字面量，因此转换后的值是十进制的56.而在ECMAScript 5 JavaScript引擎中，parseInt()已经不具有解析八进制值的能力，因此前导的零会被认为无效，从而将这个值当成”70”，结果就得到十进制的70。在ECMAScript 5 中，即使是在非严格模式下也会如此。 为了消除在使用parseInt()函数时可能导致的上述困惑，可以为这个函数第二个参数：转换时使用的技术（即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数16作为第二个参数，可以保证得到正确的结果，例如： var num=parseInt(“0xAF”,16); //175 实际上，如果指定了16作为第二个参数，字符串可以不带前面的”0x”如下所示： var num1=parseInt(“AF”,16); //175 var num2=parseInt(“AF”); //NaN 这个例子中的第一个转换成功了，而第二个则失败了。差别在于第一个转换传入了基数，明确告诉parseInt()要解析一个十六进制格式的字符串；要第二个转换发现第一个字符不是数字字符，因此就自动终止了。 1234var num1=parseInt(\"10\",2); //2 (按二进制解析)var num2=parseInt(\"10\",8); //8 (按八进制解析)var num3=parseInt(\"10\",10); //10 (按十进制解析)var num4=parseInt(\"10\",16); //16 (按十六进制解析) 不指定基数意味着让parseInt()决定如何解析输入的字符串，因此为了避免错误的解析，我们建议无论在什么情况下都明确指定基数。 与parseInt()函数类似，parseFloat()也是从第一个字符（位置0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的每一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说，”22.34.5”将会被转换为22.34。 除了第一个小数点有效之外，parseFloat()与parseInt()的第二个区别在于它始终都会忽略前导的零。parseInt()可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格式的字符串则始终被转换成0。由于parseFloat()只解析十进制值，因此它没有用第二个参数指定基数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数。以下是使用parseFloat()转换数值的几个典型示例。 123456var num1 = parseFloat(\"1234blue\"); //1234(整数)var num2 = parseFloat(\"0xA\"); //0var num3 = parseFloat(\"22.5\"); //22.5var num4 = parseFloat(\"22.34.5\"); //22.34var num5 = parseFloat(\"0908.5); //908.5var num6 = parseFloat(\"3.125e7\"); //3125000","tags":[]},{"title":"给事件处理函数传参数","date":"2017-04-09T03:05:16.000Z","path":"2017/04/09/给事件处理函数传参数/","text":"今天刷百度前端学院的任务，遇到了一个问题，需要给事件处理函数传参数；我把问题抽象成下面问题：123456789var lis = document.getElementsByTagName('li');for(var i=0; i&lt;lis.length; i++)&#123; this.i=i; btn.addEventListener('click',handler.bind(this));&#125;//我想在事件处理函数里面获得i。function handler(e)&#123; this.i;&#125; ####ES5中bind()解决：解决方法，将事件处理函数的上下文绑定到for循环里面的this；事件处理函数的上下文不在是btn对象； 分析一下原理，首先详细研究一下bind函数；bind函数用于将当前函数和指定对象绑定，返回一个新的函数，当新函数被调用时，代码会在指定对象的上下文中执行。语法为： bar.bind(上下文参数, 普通参数1, 普通参数2, …);普通参数将传入bar函数。 用jQuery中$.proxy()方法解决；jQuery.proxy(),接受一个函数，然后返回一个新函数，并且这个新函数始终保持了特定的上下文(context )语境。 jQuery.proxy( function, context )function将要改变上下文语境的函数。context函数的上下文语境(this)会被设置成这个 object 对象。 jQuery.proxy( context, name )context函数的上下文语境会被设置成这个 object 对象name将要改变上下文语境的函数名(这个函数必须是前一个参数 ‘context’ 对象的属性) 这个方法通常在向一个元素上附加事件处理函数时，上下文语境实际是指向另一个对象的情况下使用。1234567891011121314151617var obj = &#123;name: \"John\",test: function() &#123;alert( this.name );$(\"#test\").unbind(\"click\", obj.test);&#125;&#125;;$(\"#test\").click( jQuery.proxy( obj, \"test\" ) );// 以下代码跟上面那句是等价的:// $(\"#test\").click( jQuery.proxy( obj.test, obj ) );// 可以与单独执行下面这句做个比较。// $(\"#test\").click( obj.test ); / jQuery 源码之 proxy: 使用 apply 形式, 执行回调函数. /jQuery.proxy = function( fn, proxy, thisObject ) { if ( arguments.length === 2 ) { // jQuery.proxy(context, name); if ( typeof proxy === “string” ) { thisObject = fn; fn = thisObject[ proxy ]; proxy = undefined; /* 转化结果： thisObject -&gt; context fn -&gt; name proxy -&gt; undefined */ } // jQuery.proxy(name, context); else if ( proxy &amp;&amp; !jQuery.isFunction( proxy ) ) { thisObject = proxy; proxy = undefined; } } if ( !proxy &amp;&amp; fn ) { /* 使用 proxy 保证 函数执行时, context 为指定值 */ proxy = function() { return fn.apply( thisObject || this, arguments ); }; } // Set the guid of unique handler to the same of original handler, so it can be removed if ( fn ) { proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++; } // So proxy can be declared as an argument return proxy; }其实就是平常使用的的call和apply，大部分的时候作为回调使用。 在stackoverflow上有个问题，其中的例子比较典型，供参考：比如有如下代码：$(‘#myElement’).click(function() { // In this function, &quot;this&quot; is our DOM element. $(this).addClass(&apos;aNewClass&apos;); });这里的this就是我们的DOM元素。如果我们要在增加class样式之前需要等待一段时间，可能会将代码写成下面这样（注意：有问题的代码）$(‘#myElement’).click(function() { setTimeout(function() { // Problem! In this function &quot;this&quot; is not our element! $(this).addClass(&apos;aNewClass&apos;); }, 1000); });这里的this就不是我们期望的那个DOM元素了。解决方法就是使用jQuery的$.proxy()了，代码如下：$(‘#myElement’).click(function() { // ——————v——–give $.proxy our function, setTimeout($.proxy(function() { $(this).addClass(&apos;aNewClass&apos;); // Now &quot;this&quot; is again our element }, this), 1000); // —^————–and tell it that we want our DOM element to be the // value of “this” in the function });我们可以这样来理解上面的代码：function() { // v--------func is the function we gave to $.proxy func.apply( ctx ); // ----------^------ ctx is the value we wanted for &quot;this&quot; (our DOM element) }这就体现出来jQuery中$.proxy()的强大功效了。 注意：在jQuery 1.6及之后的版本中，除了上面提到的两种用法之外，proxy还增加了其他两种用法： jQuery.proxy( function, context [, additionalArguments ] )jQuery.proxy( context, name [, additionalArguments ] )","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"详细总结js中数组","date":"2017-04-09T02:07:13.000Z","path":"2017/04/09/详细总结js中数组/","text":"","tags":[]},{"title":"创建对象的几种方式总结","date":"2017-03-25T09:18:14.000Z","path":"2017/03/25/创建对象的几种方式/","text":"大三上学期看了《javasript高级程序设计》，当时看了2个月才看完，看的时候代码也对着书敲了一遍，今年作项目的时候感激有些模糊了，于是拿起书在图书馆再看一遍，对照《你不知道的js》一起，看完关上书本写博客总结一下，我认为这是一个很好的学习思考的方式，到目前为止我知道如下几种构造方式： 对象字面量 工厂模式 构造函数模式 原型模式 组合使用构造函数模式和原型模式 动态原型模式 寄生构造函数模式 稳妥构造函数模式1234567891011121314151617181920212223 //工厂模式： function createPerson(name,age,job)&#123; var obj=new Object(); obj.name=name; obj.age=age; obj.job=job; return obj; &#125; var person1=createPerson(\"shaojinghong\",21,\"software engineer\"); console.log(person1.constructor==createPerson);//false console.log(person1 instanceof createPerson);//false// 构造函数模式：function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job;&#125;var person2=new Person(\"jinghong\",21,\"software engineer\");console.log(person2.constructor==Person);//trueconsole.log(person2 instanceof Person);//true//原型模式：","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript中“this”的详细总结","date":"2017-03-24T11:15:41.000Z","path":"2017/03/24/thinking-of-this/","text":"javascript中的“this” 星期五的下午和同学ci完菠菜面，顺便买了6块钱的菠萝回宿舍开始“搞代码”这是在此博客写的第一篇文章，以前在wordpress写的文章有时间再转过来。大一大二没有写博客的习惯，倒是从大一折腾微信公众号，闲下来写写关于摄影的想法，经常拍了作品也往里放。大二下学期开始决心转计算机，还年轻梦想还是要有的，也谓之“不忘初心”。在学计算机的这一年中对我影响很大的是感悟出的一些学习方法和对知识的思考。我觉得和学本专业物理有所不同的是，对计算机知识的掌握程度不能出现“差不多理解了，似乎是这样的”。对接触到的本领域的知识要深度理解掌握，用起来才游刃有余。学计算机后对独立思考和总结开始重视了，继续加油，坚持把写博客当作一种对知识的巩固和深理解。 这一篇主要总结一下this： 调用位置 绑定规则 优先级 绑定例外 如何判断this this是什么？ this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。 this既不指向函数自身也不指向函数的词法作用域，this的绑定在调用时发生，不在词法阶段产生，this指向什么只取决于函数在哪里被调用； 绑定规则：一、默认绑定： 函数独立调用：函数直接调用不带任何修饰时，此时将应用默认绑定；例如：12345function foo()&#123; console.log(this.a);//输入1，此时this指向全局对象；&#125;var a=1;foo(); 二、 隐式绑定： 12345678var obj=&#123; a:3, foo:foo&#125;function foo()&#123; console.log(this.a);&#125;obj.foo(); foo函数的this，绑定到对象obj，obj对象中上下文调用了foo；因此this.a===obj.a; 在隐式绑定时，要注意隐式丢失的情况： 隐式丢失1:12345678910var obj=&#123; a:3, foo:foo&#125;function foo()&#123; console.log(this.a);&#125;var a=1;var b=obj.foo;b(); 结果输出1，this指向了全局对象； 虽然b是obj.foo的一个引用，但是它引用的是foo函数本身，因此函数b()实际上是一个不带任何修饰的独立函数调用，因此应用了默认绑定； 隐式丢失2:123456789101112var obj=&#123; a:3, foo:foo&#125;function b(fn)&#123; fn();&#125;function foo()&#123; console.log(this.a);&#125;var a=1;b(obj.foo); 结果输出1，this指向全局对象；参数传递是一种赋值行为，隐式赋值，所有传入的函数，也是foo函数本身； 隐式丢失3:和情形2一样，只不过是把函数传入内置函数；123456789function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo:foo&#125;var a=1;setTimeout(obj.foo,1000); 三、 显式绑定： 每个函数都包含两个非继承来的方法：apply()、call();这两个函数的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值 这两个方法可以接受两个参数，第一个是一个对象；通过foo.apply(obj)和foo.call(obj)方法将函数foo的this绑定到对象obj上。例如：12345678function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2,&#125;var a=1;foo.apply(obj); 输出结果为2. bind()方法会创建一个新函数,称为绑定函数.当调用这个绑定函数时,绑定函数会以创建它时传入bind方法的第一个参数作为this,传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数. 例如下面函数：1234567891011function foo(something)&#123; console.log(this.a,something); return this.a+something;&#125;var obj=&#123; a:2&#125;;var bar=foo.bind(obj);var b=bar(3);console.log(b); 首先要清楚：bar是一个新函数，是foo.bindd(obj)运行时产生的；然后思考函数的内容和参数分别是什么？它的内容和参数仍然和foo一样，只是里面的this对象指向obj；所以运行bar(3)时，结果是this.a+3，即2+3=5； API调用的“上下文”也是一种显式绑定实现方式；例如数组的迭代方法中的forEach()；这种方法没有返回值，它接受两个参数：要在每一项上运行的函数，该函数运行的作用域。函数传入3个三个参数：数组的值item、数组位置index、数组对象本身。 12345678var num=[1,3,3,4,6,2,2];var obj=&#123; id:\"owesome\"&#125;function foo(el)&#123; console.log(this.id,el);&#125;num.forEach(foo,obj); 输出结果：owesome 1owesome 3owesome 4owesome 6owesome 2 硬绑定：解决绑定丢失问题12345678910111213function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2,&#125;var a=1;var b=function()&#123; foo.apply(obj);&#125;b();setTimeout(b,100);bar.call(window); 输出结果都是2； 四、new绑定 先思考下面代码，重点思考new的真正含义1234567function foo()&#123; this.a=2;&#125;foo.b=3;var bar=new foo();console.log(bar.a);console.log(bar.b); 输出结果：2，undefined new 构造函数只是一些使用new操作符时被调用的函数，它们并不属于某一个类，也不会实例化一个类，甚至都不能说他们是一个特殊的函数类型。他们只是被new操作符调用的普通函数而已； 针对上述代码，new foo()；只是创建了一个新对象，这个新对象绑定到foo()调用中的this上。 四种绑定的优先级(new绑定&gt;显式绑定&gt;隐式绑定&gt;默认绑定)当某一个调用位置可以应用多种绑定时，this到底绑定到哪里呢？ 显示绑定优先于隐式绑定： 口说无凭，将隐式绑定和显式绑定加在同一个函数调用上做个实验试下：123456789101112function foo()&#123; console.log(this.a);&#125;var obj_1=&#123; a:1, foo:foo&#125;var obj_2=&#123; a:2, foo:foo&#125;obj_1.foo.apply(obj_2); 结果输出2，证明显式绑定优先于隐式绑定； new绑定优先于隐式绑定： 123456789function foo1(a)&#123; this.a=a;&#125;var obj1=&#123; a:1,&#125;var foo2=foo1.bind(obj1);var obj2=new foo2(2);console.log(obj2.a); 输出结果为2，foo1.bind(obj1)的作用是将foo的this硬绑定给obj对象，并且将这个硬绑定后的foo函数当返回值赋值给foo2。 当obj2=new foo1(2)的作用是将以下函数的this对象复制给obj2。（这里我本人理解为对象的复制，不知道是否正确，我还没好好研究对象拷贝）123function foo()&#123; this.a=2;&#125; #如何判断this step1: 函数是否在new中调用，如果是，this绑定的是新创建的对象；var a=new foo();step2: 函数是否通过call、apply或者硬绑定调用，如果是，this绑定的是call、apply、bind 参数里面指定的对象；var a=call(obj)step3: 函数是否在上下文调用中被绑定，如果是this绑定到上下文对象 var a=obj.foo();step4: 以上都不是，则使用默认绑定，在严格模式下，绑定到undefined，否则绑定到全局对象。 var bar=foo(); 绑定例外：这块儿自己还没弄明白，待更新；","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]}]