[{"title":"给事件处理函数传参数","date":"2017-04-09T03:05:16.000Z","path":"2017/04/09/给事件处理函数传参数/","text":"今天刷百度前端学院的任务，遇到了一个问题，需要给事件处理函数传参数；我把问题抽象成下面问题：123456789var lis = document.getElementsByTagName('li');for(var i=0; i&lt;lis.length; i++)&#123; this.i=i; btn.addEventListener('click',handler.bind(this));&#125;//我想在事件处理函数里面获得i。function handler(e)&#123; this.i;&#125; ####ES5中bind()解决：解决方法，将事件处理函数的上下文绑定到for循环里面的this；事件处理函数的上下文不在是btn对象； 分析一下原理，首先详细研究一下bind函数；bind函数用于将当前函数和指定对象绑定，返回一个新的函数，当新函数被调用时，代码会在指定对象的上下文中执行。语法为： bar.bind(上下文参数, 普通参数1, 普通参数2, …);普通参数将传入bar函数。 ####用jQuery中$.proxy()方法解决；jQuery.proxy(),接受一个函数，然后返回一个新函数，并且这个新函数始终保持了特定的上下文(context )语境。 jQuery.proxy( function, context )function将要改变上下文语境的函数。context函数的上下文语境(this)会被设置成这个 object 对象。 jQuery.proxy( context, name )context函数的上下文语境会被设置成这个 object 对象name将要改变上下文语境的函数名(这个函数必须是前一个参数 ‘context’ 对象的属性) 这个方法通常在向一个元素上附加事件处理函数时，上下文语境实际是指向另一个对象的情况下使用。1234567891011121314151617var obj = &#123;name: \"John\",test: function() &#123;alert( this.name );$(\"#test\").unbind(\"click\", obj.test);&#125;&#125;;$(\"#test\").click( jQuery.proxy( obj, \"test\" ) );// 以下代码跟上面那句是等价的:// $(\"#test\").click( jQuery.proxy( obj.test, obj ) );// 可以与单独执行下面这句做个比较。// $(\"#test\").click( obj.test ); / jQuery 源码之 proxy: 使用 apply 形式, 执行回调函数. /jQuery.proxy = function( fn, proxy, thisObject ) { if ( arguments.length === 2 ) { // jQuery.proxy(context, name); if ( typeof proxy === “string” ) { thisObject = fn; fn = thisObject[ proxy ]; proxy = undefined; /* 转化结果： thisObject -&gt; context fn -&gt; name proxy -&gt; undefined */ } // jQuery.proxy(name, context); else if ( proxy &amp;&amp; !jQuery.isFunction( proxy ) ) { thisObject = proxy; proxy = undefined; } } if ( !proxy &amp;&amp; fn ) { /* 使用 proxy 保证 函数执行时, context 为指定值 */ proxy = function() { return fn.apply( thisObject || this, arguments ); }; } // Set the guid of unique handler to the same of original handler, so it can be removed if ( fn ) { proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++; } // So proxy can be declared as an argument return proxy; }其实就是平常使用的的call和apply，大部分的时候作为回调使用。 在stackoverflow上有个问题，其中的例子比较典型，供参考：比如有如下代码：$(‘#myElement’).click(function() { // In this function, &quot;this&quot; is our DOM element. $(this).addClass(&apos;aNewClass&apos;); });这里的this就是我们的DOM元素。如果我们要在增加class样式之前需要等待一段时间，可能会将代码写成下面这样（注意：有问题的代码）$(‘#myElement’).click(function() { setTimeout(function() { // Problem! In this function &quot;this&quot; is not our element! $(this).addClass(&apos;aNewClass&apos;); }, 1000); });这里的this就不是我们期望的那个DOM元素了。解决方法就是使用jQuery的$.proxy()了，代码如下：$(‘#myElement’).click(function() { // ——————v——–give $.proxy our function, setTimeout($.proxy(function() { $(this).addClass(&apos;aNewClass&apos;); // Now &quot;this&quot; is again our element }, this), 1000); // —^————–and tell it that we want our DOM element to be the // value of “this” in the function });我们可以这样来理解上面的代码：function() { // v--------func is the function we gave to $.proxy func.apply( ctx ); // ----------^------ ctx is the value we wanted for &quot;this&quot; (our DOM element) }这就体现出来jQuery中$.proxy()的强大功效了。 注意：在jQuery 1.6及之后的版本中，除了上面提到的两种用法之外，proxy还增加了其他两种用法： jQuery.proxy( function, context [, additionalArguments ] )jQuery.proxy( context, name [, additionalArguments ] )","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"详细总结js中数组","date":"2017-04-09T02:07:13.000Z","path":"2017/04/09/详细总结js中数组/","text":"","tags":[]},{"title":"创建对象的几种方式总结","date":"2017-03-25T09:18:14.000Z","path":"2017/03/25/创建对象的几种方式/","text":"大三上学期看了《javasript高级程序设计》，当时看了2个月才看完，看的时候代码也对着书敲了一遍，今年作项目的时候感激有些模糊了，于是拿起书在图书馆再看一遍，对照《你不知道的js》一起，看完关上书本写博客总结一下，我认为这是一个很好的学习思考的方式，到目前为止我知道如下几种构造方式： 对象字面量 工厂模式 构造函数模式 原型模式 组合使用构造函数模式和原型模式 动态原型模式 寄生构造函数模式 稳妥构造函数模式1234567891011121314151617181920212223 //工厂模式： function createPerson(name,age,job)&#123; var obj=new Object(); obj.name=name; obj.age=age; obj.job=job; return obj; &#125; var person1=createPerson(\"shaojinghong\",21,\"software engineer\"); console.log(person1.constructor==createPerson);//false console.log(person1 instanceof createPerson);//false// 构造函数模式：function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job;&#125;var person2=new Person(\"jinghong\",21,\"software engineer\");console.log(person2.constructor==Person);//trueconsole.log(person2 instanceof Person);//true//原型模式：","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript中“this”的详细总结","date":"2017-03-24T11:15:41.000Z","path":"2017/03/24/thinking-of-this/","text":"javascript中的“this” 星期五的下午和同学ci完菠菜面，顺便买了6块钱的菠萝回宿舍开始“搞代码”这是在此博客写的第一篇文章，以前在wordpress写的文章有时间再转过来。大一大二没有写博客的习惯，倒是从大一折腾微信公众号，闲下来写写关于摄影的想法，经常拍了作品也往里放。大二下学期开始决心转计算机，还年轻梦想还是要有的，也谓之“不忘初心”。在学计算机的这一年中对我影响很大的是感悟出的一些学习方法和对知识的思考。我觉得和学本专业物理有所不同的是，对计算机知识的掌握程度不能出现“差不多理解了，似乎是这样的”。对接触到的本领域的知识要深度理解掌握，用起来才游刃有余。学计算机后对独立思考和总结开始重视了，继续加油，坚持把写博客当作一种对知识的巩固和深理解。 这一篇主要总结一下this： 调用位置 绑定规则 优先级 绑定例外 如何判断this this是什么？ this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。 this既不指向函数自身也不指向函数的词法作用域，this的绑定在调用时发生，不在词法阶段产生，this指向什么只取决于函数在哪里被调用； 绑定规则：一、默认绑定： 函数独立调用：函数直接调用不带任何修饰时，此时将应用默认绑定；例如：12345function foo()&#123; console.log(this.a);//输入1，此时this指向全局对象；&#125;var a=1;foo(); 二、 隐式绑定： 12345678var obj=&#123; a:3, foo:foo&#125;function foo()&#123; console.log(this.a);&#125;obj.foo(); foo函数的this，绑定到对象obj，obj对象中上下文调用了foo；因此this.a===obj.a; 在隐式绑定时，要注意隐式丢失的情况： 隐式丢失1:12345678910var obj=&#123; a:3, foo:foo&#125;function foo()&#123; console.log(this.a);&#125;var a=1;var b=obj.foo;b(); 结果输出1，this指向了全局对象； 虽然b是obj.foo的一个引用，但是它引用的是foo函数本身，因此函数b()实际上是一个不带任何修饰的独立函数调用，因此应用了默认绑定； 隐式丢失2:123456789101112var obj=&#123; a:3, foo:foo&#125;function b(fn)&#123; fn();&#125;function foo()&#123; console.log(this.a);&#125;var a=1;b(obj.foo); 结果输出1，this指向全局对象；参数传递是一种赋值行为，隐式赋值，所有传入的函数，也是foo函数本身； 隐式丢失3:和情形2一样，只不过是把函数传入内置函数；123456789function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo:foo&#125;var a=1;setTimeout(obj.foo,1000); 三、 显式绑定： 每个函数都包含两个非继承来的方法：apply()、call();这两个函数的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值 这两个方法可以接受两个参数，第一个是一个对象；通过foo.apply(obj)和foo.call(obj)方法将函数foo的this绑定到对象obj上。例如：12345678function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2,&#125;var a=1;foo.apply(obj); 输出结果为2. bind()方法会创建一个新函数,称为绑定函数.当调用这个绑定函数时,绑定函数会以创建它时传入bind方法的第一个参数作为this,传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数. 例如下面函数：1234567891011function foo(something)&#123; console.log(this.a,something); return this.a+something;&#125;var obj=&#123; a:2&#125;;var bar=foo.bind(obj);var b=bar(3);console.log(b); 首先要清楚：bar是一个新函数，是foo.bindd(obj)运行时产生的；然后思考函数的内容和参数分别是什么？它的内容和参数仍然和foo一样，只是里面的this对象指向obj；所以运行bar(3)时，结果是this.a+3，即2+3=5； API调用的“上下文”也是一种显式绑定实现方式；例如数组的迭代方法中的forEach()；这种方法没有返回值，它接受两个参数：要在每一项上运行的函数，该函数运行的作用域。函数传入3个三个参数：数组的值item、数组位置index、数组对象本身。 12345678var num=[1,3,3,4,6,2,2];var obj=&#123; id:\"owesome\"&#125;function foo(el)&#123; console.log(this.id,el);&#125;num.forEach(foo,obj); 输出结果：owesome 1owesome 3owesome 4owesome 6owesome 2 硬绑定：解决绑定丢失问题12345678910111213function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2,&#125;var a=1;var b=function()&#123; foo.apply(obj);&#125;b();setTimeout(b,100);bar.call(window); 输出结果都是2； 四、new绑定 先思考下面代码，重点思考new的真正含义1234567function foo()&#123; this.a=2;&#125;foo.b=3;var bar=new foo();console.log(bar.a);console.log(bar.b); 输出结果：2，undefined new 构造函数只是一些使用new操作符时被调用的函数，它们并不属于某一个类，也不会实例化一个类，甚至都不能说他们是一个特殊的函数类型。他们只是被new操作符调用的普通函数而已； 针对上述代码，new foo()；只是创建了一个新对象，这个新对象绑定到foo()调用中的this上。 四种绑定的优先级(new绑定&gt;显式绑定&gt;隐式绑定&gt;默认绑定)当某一个调用位置可以应用多种绑定时，this到底绑定到哪里呢？ 显示绑定优先于隐式绑定： 口说无凭，将隐式绑定和显式绑定加在同一个函数调用上做个实验试下：123456789101112function foo()&#123; console.log(this.a);&#125;var obj_1=&#123; a:1, foo:foo&#125;var obj_2=&#123; a:2, foo:foo&#125;obj_1.foo.apply(obj_2); 结果输出2，证明显式绑定优先于隐式绑定； new绑定优先于隐式绑定： 123456789function foo1(a)&#123; this.a=a;&#125;var obj1=&#123; a:1,&#125;var foo2=foo1.bind(obj1);var obj2=new foo2(2);console.log(obj2.a); 输出结果为2，foo1.bind(obj1)的作用是将foo的this硬绑定给obj对象，并且将这个硬绑定后的foo函数当返回值赋值给foo2。 当obj2=new foo1(2)的作用是将以下函数的this对象复制给obj2。（这里我本人理解为对象的复制，不知道是否正确，我还没好好研究对象拷贝）123function foo()&#123; this.a=2;&#125; #如何判断this step1: 函数是否在new中调用，如果是，this绑定的是新创建的对象；var a=new foo();step2: 函数是否通过call、apply或者硬绑定调用，如果是，this绑定的是call、apply、bind 参数里面指定的对象；var a=call(obj)step3: 函数是否在上下文调用中被绑定，如果是this绑定到上下文对象 var a=obj.foo();step4: 以上都不是，则使用默认绑定，在严格模式下，绑定到undefined，否则绑定到全局对象。 var bar=foo(); 绑定例外：这块儿自己还没弄明白，待更新；","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]}]