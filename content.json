[{"title":"javascript中“this”的详细总结","date":"2017-03-24T11:15:41.000Z","path":"2017/03/24/thinking-of-this/","text":"javascript中的“this” 星期五的下午和同学ci完菠菜面，顺便买了6块钱的菠萝回宿舍开始“搞代码”这是在此博客写的第一篇文章，以前在wordpress写的文章有时间再转过来。大一大二没有写博客的习惯，倒是从大一折腾微信公众号，闲下来写写关于摄影的想法，经常拍了作品也往里放。大二下学期开始决心转计算机，还年轻梦想还是要有的，也谓之“不忘初心”。在学计算机的这一年中对我影响很大的是感悟出的一些学习方法和对知识的思考。我觉得和学本专业物理有所不同的是，对计算机知识的掌握程度不能出现“差不多理解了，似乎是这样的”。对接触到的本领域的知识要深度理解掌握，用起来才游刃有余。学计算机后对独立思考和总结开始重视了，继续加油，坚持把写博客当作一种对知识的巩固和深理解。 这一篇主要总结一下this： 调用位置 绑定规则 优先级 绑定例外 this是什么？ this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。 this既不指向函数自身也不指向函数的词法作用域，this的绑定在调用时发生，不在词法阶段产生，this指向什么只取决于函数在哪里被调用； 绑定规则： 默认绑定：函数独立调用：函数直接调用不带任何修饰时，此时将应用默认绑定；例如： 12345function foo()&#123; console.log(this.a);//输入1，此时this指向全局对象；&#125;var a=1;foo(); 隐式绑定： 12345678var obj=&#123; a:3, foo:foo&#125;function foo()&#123; console.log(this.a);&#125;obj.foo(); foo函数的this，绑定到对象obj，obj对象中上下文调用了foo；因此this.a===obj.a; 在隐式绑定时，要注意隐式丢失的情况： 隐式丢失1:12345678910var obj=&#123; a:3, foo:foo&#125;function foo()&#123; console.log(this.a);&#125;var a=1;var b=obj.foo;b(); 结果输出1，this指向了全局对象； 虽然b是obj.foo的一个引用，但是它引用的是foo函数本身，因此函数b()实际上是一个不带任何修饰的独立函数调用，因此应用了默认绑定； 隐式丢失2:123456789101112var obj=&#123; a:3, foo:foo&#125;function b(fn)&#123; fn();&#125;function foo()&#123; console.log(this.a);&#125;var a=1;b(obj.foo); 结果输出1，this指向全局对象；参数传递是一种赋值行为，隐式赋值，所有传入的函数，也是foo函数本身； 隐式丢失3:和情形2一样，只不过是把函数传入内置函数；123456789function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo:foo&#125;var a=1;setTimeout(obj.foo,1000); 显式绑定： 每个函数都包含两个非继承来的方法：apply()、call();这两个函数的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值 这两个方法可以接受两个参数，第一个是一个对象；通过foo.apply(obj)和foo.call(obj)方法将函数foo的this绑定到对象obj上。例如：12345678function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2,&#125;var a=1;foo.apply(obj); 输出结果为2. bind()方法会创建一个新函数,称为绑定函数.当调用这个绑定函数时,绑定函数会以创建它时传入bind方法的第一个参数作为this,传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数. 例如下面函数：1234567891011function foo(something)&#123; console.log(this.a,something); return this.a+something;&#125;var obj=&#123; a:2&#125;;var bar=foo.bind(obj);var b=bar(3);console.log(b); 首先要清楚：bar是一个新函数，是foo.bindd(obj)运行时产生的；然后思考函数的内容和参数分别是什么？它的内容和参数仍然和foo一样，只是里面的this对象指向obj；所以运行bar(3)时，结果是this.a+3，即2+3=5； API调用的“上下文”也是一种显式绑定实现方式；例如数组的迭代方法中的forEach()；这种方法没有返回值，它接受两个参数：要在每一项上运行的函数，该函数运行的作用域。函数传入3个三个参数：数组的值item、数组位置index、数组对象本身。 12345678var num=[1,3,3,4,6,2,2];var obj=&#123; id:\"owesome\"&#125;function foo(el)&#123; console.log(this.id,el);&#125;num.forEach(foo,obj); 输出结果：owesome 1owesome 3owesome 4owesome 6owesome 2 硬绑定：解决绑定丢失问题12345678910111213function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2,&#125;var a=1;var b=function()&#123; foo.apply(obj);&#125;b();setTimeout(b,100);bar.call(window); 输出结果都是2；","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]}]