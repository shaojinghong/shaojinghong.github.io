[{"title":"javascript中“this”的详细总结","date":"2017-03-24T11:15:41.000Z","path":"2017/03/24/thinking-of-this/","text":"javascript中的“this” 星期五的下午和同学ci完菠菜面，顺便买了6块钱的菠萝回宿舍开始“搞代码”这是在此博客写的第一篇文章，以前在wordpress写的文章有时间再转过来。大一大二没有写博客的习惯，倒是从大一折腾微信公众号，闲下来写写关于摄影的想法，经常拍了作品也往里放。大二下学期开始决心转计算机，还年轻梦想还是要有的，也谓之“不忘初心”。在学计算机的这一年中对我影响很大的是感悟出的一些学习方法和对知识的思考。我觉得和学本专业物理有所不同的是，对计算机知识的掌握程度不能出现“差不多理解了，似乎是这样的”。对接触到的本领域的知识要深度理解掌握，用起来才游刃有余。学计算机后对独立思考和总结开始重视了，继续加油，坚持把写博客当作一种对知识的巩固和深理解。 这一篇主要总结一下this： 调用位置 绑定规则 优先级 绑定例外 this是什么？ this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。 this既不指向函数自身也不指向函数的词法作用域，this的绑定在调用时发生，不在词法阶段产生，this指向什么只取决于函数在哪里被调用； 绑定规则： 默认绑定：函数独立调用：函数直接调用不带任何修饰时，此时将应用默认绑定；例如： 12345function foo()&#123; console.log(this.a);//输入1，此时this指向全局对象；&#125;var a=1;foo(); 隐式绑定： 12345678var obj=&#123; a:3, foo:foo&#125;function foo()&#123; console.log(this.a);&#125;obj.foo(); foo函数的this，绑定到对象obj，obj对象中上下文调用了foo；因此this.a===obj.a; 在隐式绑定时，要注意隐式丢失的情况： 隐式丢失1:12345678910var obj=&#123; a:3, foo:foo&#125;function foo()&#123; console.log(this.a);&#125;var a=1;var b=obj.foo;b(); 结果输出1，this指向了全局对象； 虽然b是obj.foo的一个引用，但是它引用的是foo函数本身，因此函数b()实际上是一个不带任何修饰的独立函数调用，因此应用了默认绑定； 隐式丢失2:123456789101112var obj=&#123; a:3, foo:foo&#125;function b(fn)&#123; fn();&#125;function foo()&#123; console.log(this.a);&#125;var a=1;b(obj.foo); 结果输出1，this指向全局对象；参数传递是一种赋值行为，隐式赋值，所有传入的函数，也是foo函数本身； 隐式丢失3:和情形2一样，只不过是把函数传入内置函数；function foo(){ console.log(this.a);}var obj={ a:2, foo:foo}var a=1;setTimeout(obj.foo,1000);","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]}]